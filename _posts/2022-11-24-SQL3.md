---
title: "SQL 그룹조회, 조인, 서브쿼리, 입력+수정+삭제 설명"
execrpt: "SQL 그룹조회, 조인, 서브쿼리, 입력+수정+삭제 설명"
toc: true
toc_sticky: true
categories:
  - SQL
tags:
  - SQL
  - MYSQL
last_modified_at: 2022-11-25
---

## 그룹조회

### GROUP BY 절
특정 칼럼 값을 기준으로 테이블 전체 행을 그룹별로 나누기 위한 절.
```sql
select {컬럼이름 [as 별칭]..., 그룹함수(컬럼명)} from <테이블이름>
[where 검색조건]
[group by 컬럼이름]
[order by 컬럼이름 [정렬옵션]]
```
- 그룹핑 전에 where 절을 사용하여 그룹 대상을 먼저 선택 가능.
- group by 절에는 반드시 칼럼이름이 포함되어야 하며 별명 사용 불가.
- select 절에서 집계 함수 없이 나열된 칼럼 이름이나 표현식은 group by 절에 반드시 포함 되어야 함.
- group by 절에 나열된 칼럼 이름은 select 절에 명시하지 않아도 됨.
- **select 절에서 그룹함수를 사용할 경우 group by 절에서 나눈 그룹 안에서 집계를 수행한다.**
- group by절을 사용하여 deptno 칼럼을 그룹화 할 경우, name 칼럼에 대한 처리 기준이 정해지지 않았으므로 MySQL은 **각 그룹 안에서 가장 첫 번쨰 이름을 출력**한다.


![](https://user-images.githubusercontent.com/105098581/203895245-956b5956-236c-49c1-bdbe-52358f1cc18c.png)

  

- group by 절에 명시되지 않은 칼럼을 SELECT에서 사용할 경우 집계 함수를 사용하여 각 그룹별 통계 데이터를 얻을 수 있다.

```sql
select deptno, count(name) from professor group by deptno;
```

![](https://user-images.githubusercontent.com/105098581/203896082-bebaa009-5893-4b34-a527-bec5eac2ccd0.png)


ex) 교수 테이블에서 학과별로 교수 수와 보직 수당을 받는 교수 수를 출력하시오.

```sql
select deptno, count(*), count(comm)
from professor
group by deptno;
```

![](https://user-images.githubusercontent.com/105098581/203907579-b67bb9a9-e27c-4155-b69e-d016abbf225a.png)


- GROUP BY 절에서 두 개 이상의 컬럼을 콤마(,)로 구분하여 명시할 경우 첫 번째 컬럼에 대한 그룹을 형성하고, 각 그룹 안에서 두 번째 컬럼에 대한 2차 그룹을 형성한다.

```sql
select {컬럼이름 [as 별칭]..., 그룹함수(컬럼명)} from <테이블이름>
[where 검색조건]
[group by 컬럼1이름, 컬럼2이름, ..., 컬럼n이름]
[order by 컬럼이름 [정렬옵션]]
```

ex) 학생 테이블에서 전체 학생을 소속 학과별로 나누고, 같은 학과 학생은 다시 학년별로 그룹핑하여, 학과와 학년별로 인원수, 평균 몸무게를 출력  

```sql
select deptno, grade, count(*), avg(weight)
from student
group by deptno, grade;
```

![](https://user-images.githubusercontent.com/105098581/203910585-e9d85317-ecb7-4deb-b156-46dea6879c78.png)


### HAVING 절
SELECT 명령문의 WHERE절과 비슷한 기능을 하는 것으로 GROUP BY절에서 조건 검색을 할 경우 반드시 HAVING 절을 사용해야 한다.
```sql
select {컬럼이름 [as 별칭]..., 그룹함수(컬럼명)} from <테이블이름>
[where 검색조건]
[group by 컬럼1이름, 컬럼2이름, ..., 컬럼n이름]
[having 검색조건]
[order by 컬럼이름 [정렬옵션]]
```

ex) 학생 수가 4명 초과인 학년에 대해서 학년, 학생 수, 평균 키, 평균 몸무게를 출력.
  - 단, 출력순서는 평균 키가 높은 순부터 내림차순으로 출력.
  - group by 절만 사용할 경우 학생 수를 의미하는 count(*)의 결과가 4 이하인 데이터도 모두 조회된다.
  - 집계 함수에 대한 검색 조건을 지정하고자 할 경우는 group by 절 뒤에 having절을 사용해야 한다.
  - **정렬 조건에 select에서 수행한 연산이나 집계 결과를 활용해야 할 경우 select 절에서 별칭을 명시하고 이를 참조하면 정렬 과정에서 발생하는 불필요한 추가 연산을 방지할 수 있다.**

```sql
select grade, count(*), avg(height) avg_height, avg(weight) avg_weight
from student
group by grade
having count(*) > 4
order by avg_height desc;
```

![](https://user-images.githubusercontent.com/105098581/203916706-3c150092-e5cf-45fa-a80f-577f0cd261db.png)

ex) 동일 학과 내에서 같은 학년에 재학중인 학생 수가 3명 이상인 그룹의 학과번호, 학년, 학생 수, 최대 키, 최대 몸무게를 출력하세요.

```sql
select deptno, grade, count(*), max(height), max(weight)
from student
group by deptno, grade
having count(*) >= 3
order by deptno;
```

![](https://user-images.githubusercontent.com/105098581/203918154-cfa051d0-cfd7-41e5-a4de-c1da7861e47d.png)

## 연습문제

- 학과별로 학과 번호, 교수들의 평균 급여, 최소 급여, 최대 급여를 출력하여라.

```sql
SELECT deptno, AVG(sal), MIN(sal), MAX(sal)
FROM professor
GROUP BY deptno;
```

![](https://user-images.githubusercontent.com/105098581/203920441-e75dd3e3-1d50-4296-ba16-0fb8fa8f670e.png)

- 학과별로 학과번호, 평균 몸무게, 학생수를 출력하되 평균 몸무게의 내림차순으로 정렬하세요.

```sql
select deptno, avg(weight) as `평균몸무게`, count(*)
from student
group by deptno
order by 평균몸무게 desc;
```

![](https://user-images.githubusercontent.com/105098581/203921171-80742e77-c1de-4334-adbc-277c41fb748a.png)

- 학과별 교수 수가 2명 이하인 학과의 학과 번호, 교수 수를 학과번호 순으로 정렬하여 출력 하세요.

```sql
select deptno, count(*) from professor
group by deptno
having count(*) <= 2
order by deptno;
```

![](https://user-images.githubusercontent.com/105098581/203921630-e1a26bf7-347b-4d98-815d-b3e8778e59c0.png)

## 조인(JOIN)
- 교수의 소속 학과 이름을 알아보기
  - 교수의 소속 학과 이름을 알아보기 위해서는, 교수 테이블과 학과 테이블에 공통으로 포함되어 있는 학과번호(deptno) 컬럼의 값을 통해 유추해야만 한다.

![](https://user-images.githubusercontent.com/105098581/203921977-35f7f674-2504-47bf-b14c-0037596cd368.png)


### JOIN
두 개 이상의 테이블을 결합하여 필요한 데이터를 조회하는 기능.   
ex) 김도훈 교수의 이름과 소속 학과 이름을 출력하려 할 때, professor 테이블과 department 테이블을 두 번 조회 해야 하지만, 조인을 이용하면 한번에 조회가 가능하다.

![](https://user-images.githubusercontent.com/105098581/203922171-3d9e4caa-3e73-400e-9d56-86fa72a14f88.png)


- Join 의 종류 : 카티션 곱(cross join), EQUI JOIN, INNER JOIN, OUTER JOIN 등이 있다.
- JOIN의 기본 문법

```sql
select {컬럼이름 [as 별칭]...}
from <테이블1이름>, <테이블2이름>, ..., <테이블n이름>
[where 검색조건]
[group by 컬럼이름]
[order by 컬럼이름 [정렬옵션] ]
```

- 조회하고자 하는 테이블의 이름을 콤마(,)로 구분한다.
- 조인이 이루어지는 테이블에 각각 동일한 이름의 컬럼이 존재할 경우, SELECT절에서 **테이블이름.컬럼이름**의 형식으로 명시되어야 한다.

```sql
select department.deptno, professor.deptno
from department, professor;
```

- 교수 테이블과 학과 테이블을 조인하기
  - 단순히 테이블 이름을 콤마로 구분하여 나열할 경우, 32건이 조회된다.
  - 이는 두 개의 테이블에서 연결 가능한 모든 경우의 수를 조합하기 떄문에 발생하는 현상으로, 이러한 경우를 **카디션 곱**이라 한다.
  - 항상 카디션 곱이 발생하지 않도록 주의해야 한다.

![](https://user-images.githubusercontent.com/105098581/203922912-34bbe88e-7b28-49d7-bc84-b8807f21f821.png)

### EQUI JOIN

- 카디션 곱의 원인
  - where 절에서 조인 조건을 명시하지 않거나 잘못 설정하여 양쪽테이블을 연결하는 조건을 만족하는 행이 하나도 없는 경우 발생한다.
  - 카디션 곱을 해결하기 위해서는 JOIN의 조건이 되는 적절한 where절을 명시한다.
- EQUI JOIN이란?
  - SQL 문에서 가장 많이 사용되는 조인으로, 조인 대상 테이블에서 공통칼럼에 대하여'='비교를 명시해, 같은 값을 갖는 행을 연결하여 결과를 생성하는 조인 방법이다.

```sql
select table1.column, table2.column
from table1, table2
where table1.column = table2.column;
```

ex) 교수의 이름과 소속 학과 번호, 학과 이름을 조회하시오.
- professor 테이블과 department 테이블 모두 deptno 컬럼이 존재하므로, 이 값을 사용하여 JOIN 조건을 명시하되, select 절에서 deptno 컬럼을 명시할 떄에 어떤 테이블에 속한 컬럼인지를 명확히 하기 위해 **테이블이름.컬럼이름**의 형식을 사용해야 한다.

```sql
select name, department.deptno, dname from professor, department
where professor.deptno = department.deptno;
```

![](https://user-images.githubusercontent.com/105098581/203923469-494007ed-3cfa-4e57-a8af-75fd22b680c3.png)

- 테이블 이름에 대한 별칭 사용하기
  - from 절에 명시되는 테이블 이름에 공백으로 구분하여 별칭을 적용하면 select 절이나 where 절에서 풀네임을 명시하지 않아도 된다.

ex) 교수이름, 소속 학과 번호, 학과 이름을 조회하기
```sql
select p.name, d.deptno, d.dname
from professor p, department d
where p.deptno = d.deptno;
```

![](https://user-images.githubusercontent.com/105098581/203924630-c86455fb-f29f-44a1-ada3-1758ab11bdac.png)

ex) 101번 학과에 소속된 교수들의 이름, 학과번호, 학과 이름을 조회하시오.
  -  이미 JOIN의 조건을 명시하기 위해 where절이 사용되었기 떄문에,**추가적인 검색 조건은 and 연산자를 사용**한다.
  -  **검색 조건은 양쪽 테이블 중 하나에 대해서만 지정하면 된다.**

```sql
select p.name, d.deptno, d.name
from professor p, department d
where p.deptno = d.deptno and p.deptno = 101;
```

![](https://user-images.githubusercontent.com/105098581/203925279-8fc0e915-d379-4865-9374-64f08ea5bd2e.png)

### INNER JOIN
EQUI JOIN를 다른 형태로 표현한 JOIN 처리
- EQUI JOIN과 INNER JOIN의 공통점은 두 테이블 모두에서 JOIN 조건을 만족하는 교집합을 조회한다는 점이다.
- EQUI JOIN의 구문

```sql
select table1.column, table2.column
from table1, table2
where table1.column = table2.column;
```
- INNER JOIN의 구문
  - EQUI JOIN에서 테이블 이름을 구분하는 콤마(,)를 INNER JOIN이라는 키워드로 변경하고, WHERE은 ON으로 변경한다.

```sql
select table1.column, table2.column
from table1
INNER JOIN table2
on table1.column = table2.column;
```

ex) 교수이름, 소속 학과 번호, 학과 이름을 INNER JOIN으로 조회하기
```sql
select p.name, d.deptno, d.dname
from professor p
inner join department d
on p.deptno = d.deptno;
```
![](https://user-images.githubusercontent.com/105098581/203926170-d1572441-af67-48c4-ada4-86a0c9e87d8f.png)

ex) 101번 학과에 소속된 교수들의 이름, 학과번호, 학과 이름을 INNER JOIN으로 조회하시오.
  - INNER JOIN은 조인 조건에 ON 절을 사용하기 때문에, **추가적인 검색 조건은 WHERE 절을 사용**한다.

```sql
select p.name, d.deptno, d.dname
from professor p
inner join department d
on p.deptno = d.deptno
where p.deptno = 101;
```

![](https://user-images.githubusercontent.com/105098581/203926430-9068cfa2-6ea4-428b-b7e8-a36a4890ba1c.png)

### OUTER JOIN
INNER JOIN이 JOIN 조건에 부합하는 행들만 JOIN이 발생하는 것이라면, OUTER JOIN은 조건에 부합하지 않는 행들까지도 포함시켜 결합하는 것을 의미한다.

- OUTER JOIN의 종류

| 종류             | 설명                                                                                                                                                             |
| ---------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| LEFT OUTER JOIN  | 조인절에서 명시한 테이블 중, 왼쪽의 테이블에 대하여 <br />조건에 부합하지 않는 데이터까지 조회한다.                                                              |
| RIGHT OUTER JOIN | 조인절에서 명시한 테이블 중, 오른쪽의 테이블에 대하여 <br />조건에 부합히지 않는 데이터까지 조회한다.                                                            |
| FULL OUTER JOIN  | 조인에서 사용하는 모든 테이블에서 <br />조건에 부합히지 않는 데이터까지 조회한다.<br />시스템의 성능에 큰 영향을 주기 때문에<br />실무에서는 잘 사용하지 않는다. |

ex) 학생 이름과 담당 교수의 이름 조회하기
  - **EQUI JOIN과 INNER JOIN은 student테이블과 professor테이블의 profno 컬럼값이 일치하는 데이터만을 조회한다.**

![](https://user-images.githubusercontent.com/105098581/203927135-b68f085e-d99a-47f5-83a6-961e13134a7e.png)


ex) 학생의 이름과 담당교수의 이름을 조회하시오
  - 단, 담당교수가 배정되지 않은 학생의 경우 이름만 조회하시오.
  - LEFT OUTER JOIN 은 왼쪽에 지정된 테이블(student)의 모든 데이터 출력을 보장한다.

```sql
select s.name, p.name
from student s
left outer join professor p
on s.profno = p.profno;
```

![](https://user-images.githubusercontent.com/105098581/203928000-02807ca9-9dc0-4c5b-941e-2aca02900dd4.png)

ex) 학생의 이름과 담당교수의 이름을 조회하시오.
  - 단, 담당하는 학생이 없는 교수는 교수의 이름만 조회하시오.
  - RIGHT OUTER JOIN 은 오른쪽에 지정된 테이블(professor)의 모든 데이터 출력을 보장한다.

```sql
select s.name, p.name
from student s
right outer join professor p
on s.profno = p.profno;
```

ex) 학생의 이름과 학년, 소속학과의 이름과 담당교수의 이름을 모두 조회하시오.
  - 두 개 이상의 테이블을 조인하는 경우 기준이 되는 하나의 테이블을 정하고, 기준 테이블에서 다른 테이블을 조인하도록 작성한다.

```sql
select s.name, grade, d.dname, concat(p.name, ' ', p.position)
from student s, department d, professor p
where s.deptno = d.deptno and s.profno = p.profno;
```
![](https://user-images.githubusercontent.com/105098581/203929551-8436630e-0896-4db6-9f88-f393bf959089.png)

ex) 위의 예제를 inner join으로 구성하기
```sql
select s.name, grade, d.dname, concat(p.name, ' ', p.position)
from student s
inner join department d on s.deptno = d.deptno
inner join professor p on s.profno = p.profno;
```

ex) 학생의 이름, 학년, 소속학과 이름, 담당교수 이름+직급을 조회하시오. 단, 담당교수가 없는 학생의 경우 Null로 표시하시오.
  - Outer Join 구문 역시 다중 테이블 조인에서 사용할 수 있다.

```sql
select s.name, grade, d.dname, concat(p.name, ' ', p.position)
from student s
inner join department d on s.deptno = d.deptno
left outer join professor p on s.profno = p.profno;
```

![](https://user-images.githubusercontent.com/105098581/203930167-1f9ef3b0-4a59-4dac-a557-2942f9a539d4.png)

![](https://user-images.githubusercontent.com/105098581/203930167-1f9ef3b0-4a59-4dac-a557-2942f9a539d4.png)


![]()