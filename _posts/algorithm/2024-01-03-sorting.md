---
title: '정렬 알고리즘'
toc: true
toc_sticky: true
categories:
  - algorithm
tags:
  - algorithm
last_modified_at: 2024-01-03
---

- 정렬(Sorting)이란 데이터를 특정한 기준에 따라 순서대로 나열하는 것을 말합니다.
- 일반적으로 문제 상황에 따라서 적절한 정렬 알고리즘이 공식처럼 사용됩니다.

# 선택 정렬

- 처리되지 않은 데이터 중에서 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸는 것을 반복합니다.

```js
const array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8];

for (let i = 0; i < array.length - 1; i++) {
  let minIdx = i;
  for (let j = i + 1; j < array.length; j++) {
    if (array[minIdx] > array[j]) {
      minIdx = j;
    }
  }
  [array[i], array[minIdx]] = [array[minIdx], array[i]];
  /*
   if (minIndex !== i) {
    const temp = arr[i];
    arr[i] = arr[minIndex];
    arr[minIndex] = temp;
  }
  */
}

console.log(array); // [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
```

### 선택 정렬의 시간 복잡도

- 선택 정렬은 N번 만큼 가장 작은 수를 찾아서 맨 앞으로 보내야 합니다.
- 구현 방식에 따라서 사소한 오차는 있을 수 있지만, 전체 연산 횟수는 다음과 같습니다

N + (N - 1) + (N - 2) + … + 2

- 이는 (N^2 + N - 2) / 2 로 표현할 수 있는데, 빅오 표기법에 따라서 O(N^2)이라고 작성합니다.

# 삽입 정렬

- 처리되지 않은 데이터를 하나씩 골라 적절한 위치에 삽입합니다.
- 선택 정렬에 비해 구현 난이도가 높은 편이지만, 일반적으로 더 효율적으로 동작합니다.

```jsx
const array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8];

for (let i = 1; i < array.length; i++) {
  for (let j = i; j > 0; j--) {
    if (array[j - 1] < array[j]) break;
    [array[j], array[j - 1]] = [array[j - 1], array[j]];
  }
}

console.log(array);
```

### 삽입 정렬의 시간 복잡도

- 삽입 정렬의 시간 복잡도는 O(N^2)이며, 선택 정렬과 마찬가지로 반복문이 두 번 중첩되어 사용됩니다.
- 삽입 정렬은 현재 리스트의 데이터가 거의 정렬되어 있는 상태라면 매우 빠르게 동작합니다.
  - 최선의 경우 O(N)의 시간 복잡도를 가집니다.

# 퀵 정렬

- 기준 데이터를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸는 방법입니다.
- 일반적인 상황에서 가장 많이 사용되는 정렬 알고리즘 중 하나입니다.
- 병합 정렬과 더불어 대부분의 프로그래밍 언어의 정렬 라이브러리의 근간이 되는 알고리즘입니다.
- 가장 기본적인 퀵 정렬은 **첫 번째 데이터를 기준 데이터(Pivot)로 설정**합니다.

- 퀵 정렬은 평균의 경우 O(NlogN)의 시간 복잡도를 가집니다.
- 하지만 최악의 경우 O(N^2)의 시간 복잡도를 가집니다.

```js
const arr = [5, 7, 9, 0, 3, 1, 6, 2, 4, 8];
const n = arr.length;

const quickSort = (arr, start, end) => {
  if (start >= end) return; // 원소가 하나일 경우 종료

  const pivot = start;
  let left = start + 1;
  let right = end;
  while (left <= right) {
    // 피벗보다 큰 데이터를 찾을 때 까지 탐색
    while (left <= end && arr[pivot] >= arr[left]) {
      left++;
    }

    // 피벗보다 작은 데이터 찾을 때까지 탐색
    while (right > start && arr[pivot] <= arr[right]) {
      right--;
    }

    // swap
    if (left > right) {
      [arr[pivot], arr[right]] = [arr[right], arr[pivot]];
    } else {
      [arr[left], arr[right]] = [arr[right], arr[left]];
    }
  }
  quickSort(arr, start, right - 1);
  quickSort(arr, right + 1, end);
};

quickSort(arr, 0, n - 1);
console.log(arr);
```

# 계수 정렬

- 특정한 조건이 부합할 때만 사용할 수 있지만 매우 빠르게 동작하는 정렬 알고리즘입니다.
  - 계수 정렬은 데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때 사용 가능합니다.
- 데이터의 개수가 N, 데이터(양수) 중 최대값이 K일 때 최악의 경우에도 수행 시간 O(N + K)를 보장합니다.

```js
const arr = [7, 5, 9, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5, 2];
const count = [...Array(Math.max(...arr) + 1).fill(0)];

arr.forEach((num) => count[num]++);

let sorted = '';
for (let num = 0; num < count.length; num++) {
  sorted += num.toString().repeat(count[num]);
}

console.log([...sorted]);
```

### 복잡도 분석

- 계수 정렬의 시간 복잡도, 공간 복잡도는 모두 O(N+K)입니다.
- 계수 정렬은 떄에 따라서 심각한 비효율성을 초래할 수 있습니다.
  - 데이터가 0과 999,999로 단 2개만 존재하는 경우를 생각해 봅시다.
- 계수 정렬은 동일한 값을 가지는 데이터가 여러 개 등장할 때 효과적으로 사용할 수 있습니다.
  - 성적의 경우 100점을 맞은 학생이 여러 명일 수 있기 떄문에 계수 정렬이 효과적입니다.

# 정렬 알고리즘 비교하기

- 앞서 다룬 네 가지 정렬 알고리즘을 비교하면 다음과 같습니다.
- 추가적으로 대부분의 프로그래밍 언어에서 지원하는 표준 정렬 라이브러리는 최악의 경우에도 O(logN)을 보장하도록 설계되어 있습니다.

| 정렬 알고리즘 | 평균 시간 복잡도 | 공간 복잡도 | 특징                                                                            |
| ------------- | ---------------- | ----------- | ------------------------------------------------------------------------------- |
| 선택 정렬     | O(N^2)           | O(N)        | 아이디어가 매우 간단합니다.                                                     |
| 삽입 정렬     | O(N^2)           | O(N)        | 데이터가 거의 정렬되어 있을 때는 가장 빠릅니다.                                 |
| 퀵 정렬       | O(NlogN)         | O(N)        | 대부분의 경우에 가장 적합하며, 충분히 빠릅니다.                                 |
| 계수 정렬     | O(N + K)         | O(N + K)    | 데이터의 크기가 한정되어 있는 경우에만 사용할 수 있지만 매우 빠르게 동작합니다. |

### <문제> 두 배열의 원소 교체 : 문제 설명

- 동빈이는 두 개의 배열 A와 B를 가지고 있습니다. 두 배열은 N개의 원소로 구성되어 있으며, 배열의 원소는 모두 자연수입니다.
- 동빈이는 최대 K 번의 바꿔치기 연산을 수행할 수 있는데, 바꿔치기 연산이란 배열 A에 있는 원소 하나와 배열 B에 있는 원소 하나를 골라서 두 원소를 서로 바꾸는 것을 말합니다.
- 동빈이의 최종 목표는 배열 A의 모든 원소의 합이 최대가 되도록 하는 것이며, 여러분은 동빈이를 도와야합니다.
- N, K, 그리고 배열 A와 B의 정보가 주어졌을 떄, 최대 K 번의 바꿔치기 연산을 수행하여 만들 수 있는 배열 A의 모든 원소의 합의 최댓값을 출력하는 프로그램을 작성하세요.
- 예를 들어 N = 5, K = 3이고, 배열 A와 B가 다음과 같다고 해봅시다.
  - 배열 A = [1,2,5,4,3]
  - 배열 B = [5,5,6,6,5]
- 이 경우, 다음과 같이 세 번의 연산을 수행할 수 있습니다.
  - 연산 1) 배열 A의 원소 ‘1’과 배열 B의 원소 ‘6’을 바꾸기
  - 연산 2) 배열 A의 원소 ‘2’과 배열 B의 원소 ‘6’을 바꾸기
  - 연산 3) 배열 A의 원소 ‘3’과 배열 B의 원소 ‘5’을 바꾸기
- 세 번의 연산 이후 배열 A와 배열 B의 상태는 다음과 같이 구성될 것입니다.
  - 배열 A = [6,6,5,4,5]
  - 배열 B = [3,5,1,2,5]
- 이때 배열 A의 모든 원소의 합은 26이 되며, 이보다 더 합을 크게 만들 수는 없습니다.

입력 조건

- 첫 번쨰 줄에 N, K가 공백을 기준으로 구분되어 입력됩니다. (1 ≤N≤100,000, 0≤ K ≤N)
- 두 번째 줄에 배열 A의 원소들이 공백을 기준으로 구분되어 입력됩니다. 모든 원소는 10,000,000보다 작은 자연수입니다.
- 세 번째 줄에 배열 B의 원소들이 공백을 기준으로 구분되어 입력됩니다. 모든 원소는 10,000,000보다 작은 자연수입니다.

출력 조건

- 최대 K번의 바꿔치기 연산을 수행하여 만들 수 있는 배열A의 모든 원소의 합의 최댓값을 출력합니다.

입력 예시

5 3

1 2 5 4 3

5 5 6 6 5

출력 예시

26

### 문제 해결 아이디어

- 핵심 아이디어 : 매번 배열 A에서 가장 작은 원소를 골라서, 배열 B에서 가장 큰 원소와 교체합니다.
- 가장 먼저 배열 A와 B가 주어지면 A에 대하여 오름차순 정렬하고, B에 대하여 내림차순 정렬합니다.
- 이후에 두 배열의 원소를 첫 번째 인덱스부터 차례로 확인하면서 A의 원소가 B의 원소보다 작을 때에만 교체를 수행합니다.
- 이 문제에서는 두 배열의 원소가 최대 100,000개까지 입력될 수 있으므로, 최악의 경우 O(NlogN)을 보장하는 정렬 알고리즘을 이용해야 합니다.

```jsx
function getMaxSum(N, K, arrA, arrB) {
  arrA.sort((a, b) => a - b); // 배열 A는 오름차순 정렬
  arrB.sort((a, b) => b - a); // 배열 B는 내림차순 정렬

  for (let i = 0; i < K; i++) {
    if (arrA[i] < arrB[i]) {
      // 배열 A의 값이 배열 B의 값보다 작을 때만 교환
      [arrA[i], arrB[i]] = [arrB[i], arrA[i]];
    } else {
      // 더 이상 바꿔치기 연산을 할 필요가 없을 때 종료
      break;
    }
  }

  // 배열 A의 모든 원소의 합 계산
  const sum = arrA.reduce((acc, curr) => acc + curr, 0);
  return sum;
}

const input = '5 3\n1 2 5 4 3\n5 5 6 6 5';
const [N, K] = input.split('\n')[0].split(' ').map(Number);
const arrA = input.split('\n')[1].split(' ').map(Number);
const arrB = input.split('\n')[2].split(' ').map(Number);

const result = getMaxSum(N, K, arrA, arrB);
console.log(result); // 26
```
