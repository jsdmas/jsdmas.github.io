---
title: 'JWT'
toc: true
toc_sticky: true
categories:
  - theory
tags:
  - theory
last_modified_at: 2024-01-15
---

# 토큰 기반 시스템의 작동 원리

토큰 기반 시스템은 Stateless 합니다. 즉 상태유지를 하지 않습니다. 이 시스템에서는 더 이상 유저의 인증정보를 서버나 세션에 담아두지 않습니다.

세션이 존재하지 않으니, 유저들이 로그인 되어있는지 안되어있는지 신경을 쓰지 않기 때문에 서버 확장이 쉽게 가능합니다.

대략적인 인증 절차는 아래와 같습니다.

1. 유저가 id, pw를 입력하여 로그인을 합니다.
2. 서버측에서 해당 계정정보를 검증합니다.
3. 계정정보가 정확하다면, 서버측에서 유저에게 signed 토큰을 발급해줍니다.

- signed의 의미는 토큰이 서버에서 정상적으로 발급된 토큰임을 증명하는 signature를 지니고 있다는 것을 의미합니다.

4. 클라이언트 측에서 전달받은 토큰을 저장해두고, 서버에 요청을 ㅂ할 때 마다, 해당 토큰을 함께 서버에 전달합니다.
5. 서버는 토큰을 검증하고, 요청에 응답합니다.

![image](https://github.com/jsdmas/jsdmas.github.io/assets/105098581/d5844257-2d84-49da-bffc-b02e7c1ae076)

> 웹 서버에서 토큰을 서버에 전달 할 떄는, HTTP Request 헤더에 토큰값을 포함시켜서 전달합니다.

# 토큰의 장점

## 무상태(stateless)이며 확장성(scalability)

이 개념은 토큰 기반 인증 시스템의 중요한 속성입니다. 토큰은 클라이언트 사이드에 저장하기 떄문에 완전히 `stateless`하며, 서버를 확장하기에 매우 적합한 환경을 제공합니다. 만약에 세션을 서버측에 저장하고 있고, 서버를 여러대를 사용하여 요청을 분산하였다면, 어떤 유저가 로그인 했을떈, 그 유저는 처음 로그인했었던 해당 서버에만 요청을 보내도록 설정을 해야합니다. 하지만 토큰을 사용한다면 어떤 서버로 요청이 들어가던 상관이 없습니다.

## 보안성

클라이언트가 서버에 요청을 보낼 떄, 더 이상 쿠키를 전달하지 않음으로 쿠키를 사용함으로 인해 발생하는 취약점이 사라집니다. (JWT는 클라이언트가 서버에 요청을 보낼 시 헤더에 포함되어 전달된다.) 토큰을 사용하는 환경에서도 취약점이 존재할 수 있으니 언제나 취약점에

## 확장성

토큰을 사용하여 다른 서비스에서도 권한을 공유 할 수 있습니다. 예를 들어서, 스타트업 구인구직 웹서비스인 로켓펀치에서는 Facebook, LinkedIn, GitHub, Google 계정으로 로그인을 할 수 있습니다. 토큰 기반 시스템에서는, 토큰에 선택적인 권한만 부여하여 발급을 할 수 있습니다. (예를들어서 로켓펀치에서 페이스북 계정으로 로그인을 했다면, 프로필 정보를 가져오는 권한은 있어도, 포스트를 작성 할 수 있는 권한은 없습니다.)

# JWT(JSON Web Token) 개념&예시

JWT는 Claim 기반의 토큰입니다. Claim이라는 사용자에 대한 프로퍼티나 속성을 이야기 합니다. 토큰자체가 정보를 가지고 있는 방식인데, JWT는 이 Claim을 JSON을 이용해서 정의합니다. 다음은 Claim을 JSON으로 서술한 예입니다. JSON 자체를 토큰으로 사용하는 것이 Claim 기반의 토큰 방식입니다.

```
{
  "id" : "jinho",
  "message" : "바보"
}
```

이러한 Claim 방식 토큰의 장점은 토큰을 이용해서 요청을 받는 서버나 서비스 입장에서는 이 서비스를 호출한 사용자에 대한 추가 정보는 이미 토큰안에 다 들어가 있기 때문에 다른 곳에서 가져올 필요가 없다는 것입니다.

`사용자 관리`라는 API 서비스가 있다고 가정합니다.  
이 API는 `관리자(admin)`권한을 가지고 있는 사용자만이 접근 가능하며, `관리자`권한을 가지고 있는 사용자는 그 관리자가 속해 있는 `회사(company)`의 사용자 정보만 관리할 수 있다고 정의해봅시다. 이 시나리오에 대해서 일반적인 스트링 기반의 토큰과 JWT와 같은 Claim 기반의 토큰이 어떤 차이를 가질 수 있는지 알아보겠습니다.

## OAuth 토큰의 경우

![image](https://github.com/jsdmas/jsdmas.github.io/assets/105098581/83ae53a7-686f-4d3f-85d2-b1a397ed1141)

1. API client가 Authorization Server(토큰 발급서버)로 토큰을 요청합니다. 이떄, 토큰 발급을 요청하는 사용자의 계정과 비밀번호를 넘기고, 이와 함께 토큰의 권한(용도)를 요청합니다. 여기서는 일반 사용자 권한(basic)과 관리자 권한(admin)을 같이 요청했습니다.
2. 토큰 생성 요청을 받은 Authorization Server는 사용자 계정을 확인한 후, 이 사용자에게 요청된 권한을 부여해도 되는지 계정 시스템등에 물어본 후, 사용자에게 해당 토큰을 발급이 가능하면 토큰을 발급하고, 토큰에 대한 정보를 내부(토큰 저장소)에 저장해놓습니다.
3. 이렇게 생선된 토큰은 API 클라이언트로 저장됩니다.
4. API 클라이언트는 API를 호출할떄 이 토큰을 이용해서 Resource Server(API 서버)에 있는 API를 호출합니다.
5. 이떄 호출되는 API는 관리자 권한을 가지고 있어야 사용할 수 있기 때문에, Resource Server가 토큰 저장소에서 토큰에 관련된 사용자 계정, 권한 등의 정보를 가지고 옵니다. 이 토큰에 관리자 권한이 부여되어 있기 때문에, API 호출을 허용합니다. 위에 정의한 시나리오에서는 그 사용자가 속한 회사의 사용자 정보만 조회 가능합니다. 라는 전제조건을 가지고 있기 때문에, API 서버는 추가로 사용자 데이터 베이스에서 이 사용자가 속한 회사 정보를 찾아와야 합니다.
6. API 서버는 응답을 보냅니다.

## JWT와 같은 Claim 기반의 토큰 흐름

![image](https://github.com/jsdmas/jsdmas.github.io/assets/105098581/e49cc112-b5c6-4cb5-acb9-33ee12236f1e)

1. 토큰을 생성 요청하는 방식은 동일합니다. 마찬가지로 사용자를 인증한다음에, 토큰을 생성합니다.
2. 다른 점은 생성된 토큰에 관련된 정보를 별도로 저장하지 않는다는 것입니다. 토큰에 연관되는 사용자정보나 권한등을 토큰 자체에 넣어서 저장합니다.
3. API를 호출하는 방식도 동일합니다.
4. Resource Server (API서버)는 토큰 내에 들어 있는 사용자 정보를 가지고 권한 인가 처리를 하고 결과를 리턴합니다.

> 차이점은 토큰을 생성하는 단계에서는 생성된 토큰을 별도로 서버에서 유지할 필요가 없으며 토큰을 사용하는 API 서버 입장에서는 API 요청을 검증하기 위해서 토큰을 가지고 사용자 정보를 별도로 계정 시스템 등에서 조회할 필요가 없다는 것입니다.

# JWT 소개

## Claim (메시지)

JWT는 Claim을 JSON 형태로 표현하는 것인데, JSON은 '\n' 등 개행문자가 있기 때문에, REST API 호출시 HTTP Header등에 넣기가 매우 불편합니다. 그래서 이 Claim JSON 문자열을 BASE64 인코딩을 통해서 하나의 문자열로 변환합니다.

```
{
  "id" : "jinho",
  "role" : ["admin", "user"],
  "company" : "asdf"
}
```

문자열 BASE64 인코딩 결과

> ew0KICAiaWQiOiJ0ZXJyeSINCiAgL......

### BASE64 인코딩

- 2진 데이터를 ASCII 형태의 텍스트로 표현 가능
- 웹 인증 중 기본인증에 사용
- 끝 부분의 Padding(==)으로 식별 가능
- 64개의 문자 사용 (영문 대, 소문자, 숫자 , + , / )
- 데이터를 6bit 단위로 표현

## 변조 방지

위의 Claim 기반의 토큰을 봤다면, 첫 번째로 들 수 있는 의문이 토큰을 받은 다음에 누군가 토큰을 변조해서 사용한다면 어떻게 막느냐 입니다. 이렇게 메시지가 변조 되지 않았음을 증명하는 것을 무결성(Integrity)라고 하는데, 무결성을 보장하는 방법 중 많이 사용되는 방법이 서명(Signature)이나 HMAC 사용하는 방식입니다.

즉 원본 메시지에서 해쉬값을 추출한 후, 이를 비밀 키를 이용해 복화화 시키서 토큰의 뒤에 붙입니다. 이게 HMAC 방식인데, 누군가 이 메시지를 변조했다면, 변조된 메시지에서 생성한 해쉬값과 토큰뒤에 붙어있는 해쉬값이 다르기 떄문에 메시지가 변조되었음을 알 수 있습니다. 다른 누군가가 메시지를 변조한 후 새롭게 HMAC 값을 만들어내려 해도 HMAC은 앞의 비밀키를 이용해 복호화 되었기 때문에, 이 비밀키를 알 수 없는 이상 HMAC을 만들어 낼 수 없습니다.

앞의 JSON 메시지에 대해서 SHA-256이라는 알고리즘을 이용해서 비밀키를 'secret'이라고 하고, HMAC을 생성하면 결과는 다음과 같습니다.

> erwewr2mRxfSB5gt0rLbtrogxbKj...

## JWT 기본 구조

```
Header, Payload, Signature
```

### Header

> JWT 웹 토큰의 헤더 정보

- typ : 토큰의 타입, JWT만 존재
- alg : 해싱 알고리즘.(HMAC SHA256 or RSA) 헤더를 암호화 하는게 아닙니다. 토큰 검증시 사용합니다.

```
{
  "alg" : "HS256",
  "typ" : "JWT"
}
```

위의 내용을 BASE64로 인코딩합니다. => eyJhbGciO....

BASE64는 암호화된 문자열이 아닙니다. 같은 자열에 대해서는 항상 같은 인코딩 문자열을 반환합니다.

### Payload

> 살재 토큰으로 사용하려는 데이터가 담기는 부분. 각 데이터를 Claim이라고 하며 다음과 같이 3가지 종류가 있다.

- Reserved claims: 이미 예약된 Claim. 필수는 아니지만 사용하길 권장합니다. key는 모두 3자리 String입니다.
  - iss(String): issuer, 토큰 발행자 정보
  - exp(Number): expiration time, 만료일
  - sub(String): subject, 제목
  - and(String): audience
- Public claims: 사용자 정의 Claim
  - Public이라는 이름처럼 공개용 정보
  - 충돌 방지를 위해 URI 포맷을 이용해 저장합니다.
- Private Claims: 사용자 정의 Claim
  - Public claims과 다르게 사용자가 임의로 정한 정보
  - 아래와 같이 일반 정보를 저장합니다.
    ```
    {
      "name" : "jinho",
      "age" : 26
    }
    ```

### Signature

> Header와 Payload의 데이터 무결성과 변조 방지를 위한 서명
> Header + Payload를 합친 후, Secret 키와 함께 Header의 해싱 알고리즘으로 인코딩

```
HMACSHA256(
    base64UrlEncode(header) + "." +
    base64UrlEncode(payload),
    secret)
```

> JWT는 [Header Payload Signature] 각각 JSON 형태의 데이터를 base 64 인코딩 후 합칩니다.
> 아래와 같은 순서로 . 을 이용해 합칩니다.
> 최종적으로 만들어진 토큰은 HTTP 통신 간 이용되며, Authorization 이라는 key의 value로서 사용됩니다.

![image](https://github.com/jsdmas/jsdmas.github.io/assets/105098581/8a03cc51-0b03-418d-aebd-f95899eb600c)

# 인증 과정

![image](https://github.com/jsdmas/jsdmas.github.io/assets/105098581/f6936de3-fd0a-4b2c-a2d7-374cc5c1b4ca)

# JWT의 단점 & 도입시 고려사항

- 토큰 길이: 토큰 자체 payload에 Claim set을 저장하기 때문에 정보가 많아질수록 토큰의 길이가 늘어나 네트워크에 부하를 줄 수있습니다.

- payload 암호화: payload 자체는 암호화 되지 않고 base64로 인코딩한 데이터입니다. 중간에 payload를 탈취하면 디코딩을 통해 데이터를 볼 수 있습니다. payload에 중요 데이터를 넣지 않아야 합니다.

- Stateless: 무상태성이 때론 불편할 수 있습니다. 토큰은 한번 만들면 서버에서 제어가 불가능합니다. 토큰을 임의로 삭제할 수 있는 방법이 없기 때문에 토큰 만료시간을 꼭 넣어주는게 좋습니다.

- Store Token: 토큰은 클라이언트 side에서 관리해야하기 때문에 토큰을 저장해야 합니다.

# 출처

[출처\_링크](https://velog.io/@sa1341/JWT-%ED%86%A0%ED%81%B0-%EC%9D%B8%EC%A6%9D#9-jwt-%EC%9D%B8%EC%A6%9D-%EA%B3%BC%EC%A0%95)
